"""
Adds export/import to NIH files
Adds Talos+ related methods
"""
import sys
import os

import cing
from cing import constants
from cing.core import validation
from cing.Libs import io
from cing.core.classes import jsonTools as jsonTools
import cing.constants.definitions as cdefs


from cing.Libs.Adict import Adict
from cing.Libs.AwkLike import AwkLike

from cing.Libs.fpconst import NaN

#from cing.Libs.NTutils import * #@UnusedWildImport
from cing.Libs.NTutils import NTdict
from cing.Libs.NTutils import NTlist
from cing.Libs.NTutils import NTvalue

from cing.Libs.NTutils import nTerror
from cing.Libs.NTutils import nTwarning
from cing.Libs.NTutils import nTmessage
from cing.Libs.NTutils import nTdebug
from cing.Libs.NTutils import nTmessageNoEOL
from cing.Libs.NTutils import getDeepByKeysOrAttributes
from cing.Libs.NTutils import ExecuteProgram
from cing.Libs.NTutils import getOsResult

from cing.Libs.io import sprintf
from cing.Libs.io import fprintf

from cing.core.classes import DihedralRestraint

from cing.constants.definitions import cingDefinitions
from cing.constants.definitions import directories

# versions < 0.95 not logged with version number
# cing versions >1.0 first ones to include this
__version__ = cing.__version__


# defaults for the talosPlus status dict
talosDefaults= dict(
    completed    = False,
    parsed       = False,
    version      = __version__,
    directory    = constants.TALOSPLUS_KEY,
    tableFile    = 'talosPlus.tab', # file generated by CING
    predFile     = 'pred.tab',      # file with predictions returned by Talos(+)
    predSSFile   = 'predSS.tab',    # file with sec struct returned by Talos(+): pred.ss.tab also encountered
    molecule     = None
)


class TalosPlusResult( validation.ValidationResult ):
    """Class to store Talos+ results

    Reference: Shen et al., 2009, J. Biomol. NMR 44, 213-223
    Reference: Predicted order parameter (S2) from backbone chemical shifts for talosPlus.tab
              from David Wishart's RCI method, JACS, 127(43), 14970-14971
    """
    KEY            = constants.TALOSPLUS_KEY
    PHI            = 'phi'
    PSI            = 'psi'
    COUNT          = 'count'
    CLASSIFICATION = 'classification'
    S2             = 'S2'
    SS_CLASS       = 'ss_class'
    SS_CONFIDENCE  = 'ss_confidence'
    Q_H            = 'Q_H'
    Q_E            = 'Q_E'
    Q_L            = 'Q_L'

    def __init__(self):

        validation.ValidationResult.__init__(self)
        self.setdefault(TalosPlusResult.PHI, None)
        self.setdefault(TalosPlusResult.PSI, None)
        self.setdefault(TalosPlusResult.COUNT, 0)
        self.setdefault(TalosPlusResult.CLASSIFICATION, None)
        self.setdefault(TalosPlusResult.S2, NaN)
        self.setdefault(TalosPlusResult.SS_CLASS, None)
        self.setdefault(TalosPlusResult.SS_CONFIDENCE, None)
        self.setdefault(TalosPlusResult.Q_E, NaN)
        self.setdefault(TalosPlusResult.Q_H, NaN)
        self.setdefault(TalosPlusResult.Q_L, NaN)
        self.setdefault(TalosPlusResult.OBJECT_KEY, None)
        self.setdefault('residue', None) #LEGACY:
    #end def

    def format(self, fmt=None):
        if fmt is None:
            fmt = '%(residue)-18s  phi= %(phi)-15s  psi= %(psi)-15s  (%(count)2s predictions, classified as ' +\
                  '"%(classification)-4s")  S2= %(S2)4.2f   Sec.Struct.: %(ss_class)-8s ' +\
                  '(confidence: %(ss_confidence)4.2f)'
            return fmt % self
        else:
            return fmt.format(**self)
    #end if
#end class


class TalosPlusResultJsonHandler(jsonTools.handlers.AnyDictHandler):
    """Handler for the TalosPlusResult class
    """
    namespace = cing.constants.TALOSPLUS_KEY
    cls = TalosPlusResult
    encodedKeys = [cing.constants.OBJECT_KEY,'residue']
#end class
TalosPlusResultJsonHandler.handles(TalosPlusResult)


# Python Tablefile implementation
# Formerly in Talos/NmrPipeTable.py
class NmrPipeTabRow( NTdict ):
    """
    Class defining a row in a nmrTable file
    """

    def __init__( self, table, id, **kwds ):
        NTdict.__init__( self, __CLASS__  = 'NmrPipeTabRow',
                                 table      = table,
                                 id         = id,
                                 name       = 'row'+str(id),
                                 __FORMAT__ = '%(name)s',
                                 **kwds
                          )
        # set defaults to None
        for c in self.keys():
            self.setdefault( c, None )
        #end for
    #end def

    def keys( self ):
        """overide keys method to define collums as 'active' items"""
        keys = []
        for c in self.table.columnDefs:
            keys.append( c.name )
        return keys
    #end def

    def __iter__( self ):
        for v in self.values():
            yield v
        #end for
    #end def

    def __str__( self ):
        r = ''
        for col in self.table.columnDefs:
            if not col.hide:
                if self[col.name] == None:
                    dot=col.fmt.find('.')
                    if dot < 0:
                        fmt = col.fmt[:-1] + 's'
                    else:
                        fmt = col.fmt[0:dot] + 's'
                    #endif

                    r = r + fmt % (self.table.noneIndicator) + ' '
                else:
                    r = r + sprintf(col.fmt, self[ col.name ] ) + ' '
                #end if
            #end if
        #end for
        return r
    #end def
#end class


class NmrPipeTable( NTdict ):
    """
    NmrPipeTable class
    implemented as NTdict of NTdict's, i.e.

    element (row-0, INDEX) indexed as
        tab[0].INDEX   or tab[0]['INDEX']

    tab = NmrPipeTable()                # Empty table
    tab = NmrPipeTable( 'tabFile' )     # table from tabFile

    METHODS:

    addColumn( name, fmt = "%s", default=None ):
        Add column 'name' to table; set values to 'default'

    hideColumn( *cNames )
        Hide column(s) cNames

    showColumn( *cNames )
        Show columns cNames

    addRow( **kwds ):
        Add row to table, optional kwds can be used to set values

    readFile( tabFile  ):
        Read table from tabFile

    write( stream=sys.stdout ):
        Write table to stream

    writeFile( tabFile)   :
        Open tabFile, write table and close tabFile

    """

    def __init__( self, tabFile=None, **kwds ):
        NTdict.__init__( self, __CLASS__ = 'nmrPipeTab', **kwds )

        self.setdefault('noneIndicator', '-') # character to identify the None value

        self.columnDefs = NTlist()          # list of column definitions, implemented
                                            # as NTdict
        self.rows       = NTlist()
        self.nrows      = 0
        self.remarks    = NTlist()
        self.data       = NTdict()
        self.tabFile    = tabFile

        if tabFile:
            self.readFile( tabFile  )
        #end if
    #end def

    def format(self): # pylint: disable=W0221
        return sprintf(
'''=== NmrPipeTable "%s" ===
columns:  %s
nrows:    %d''', self.tabFile, self.columnDefs.zap('name'), self.nrows
        )


    def addRow( self, **kwds ):
        """
        Add row to table, optional kwds can be used to set values
        """
        row = NmrPipeTabRow( table=self, id=self.nrows, **kwds )
        self[ self.nrows ] = row
        self.rows.append( row )
        self.nrows += 1
        return row
    #end def

    def addColumn( self, name, fmt = "%s", default=None ):
        """
        Add column 'name' to table; set values to 'default'
        return columnDef, or None on error
        """
        if name in self:
            nTerror('NmrPipeTable.addColumn: column "%s" already exists\n', name )
            return None
        #end if

        col = NTdict( name=name,
                        fmt=fmt,
                        id=len(self.columnDefs),
                        hide=False,
                        __FORMAT__ = '%(name)s'
                      )
        self.columnDefs.append( col )
        self[name] = col
        for row in self:
            row[name] = default
        #end for

        return col
    #end def

    def column( self, cName ):
        """Return list of values of column cName or None on error
        """
        if cName not in self:
            return None

        col = NTlist()
        for row in self:
            col.append( row[cName] )
        #end for
        return col
    #end def

    def hideColumn( self, *cNames ):
        """
        Hide column(s) cNames
        """
        for c in cNames:
            if not c in self:
                nTerror('NmrPipeTable.hideColumn: column "%s" not defined\n', c)
            else:
                self[c].hide = True
            #end if
        #end for
    #end def

    def showColumn( self, *cNames ):
        """
        Show column(s) cNames
        """
        for c in cNames:
            if not c in self:
                nTerror('NmrPipeTable.showColumn: column "%s" not defined\n', c)
            else:
                self[c].hide = False
            #end if
        #end for
    #end def

    def readFile( self, tabFile  ):
        """
        Read table from tabFile
        """
#        nTmessage('Reading nmrPipe table file %s', tabFile )

        #end if

        for line in AwkLike( tabFile, minNF = 1, commentString = '#' ):
            if ( line.dollar[1] == 'REMARK' and line.NF > 1 ):
                self.remarks.append( line.dollar[2:] )

            elif ( line.dollar[1] == 'VARS' ):
                for v in line.dollar[2:]:
                    self.addColumn( name=v )
                #end for
            elif ( line.dollar[1] == 'FORMAT' ):
                i = 0
                for f in line.dollar[2:]:
                    self.columnDefs[i].fmt=f
                    i += 1
                #end for
            elif ( line.dollar[1] == 'DATA' and line.NF > 3 ):
                self.data[line.dollar[2]] = line.dollar[3:]

            elif ( line.NF == len( self.columnDefs ) ):
                row = self.addRow()
                for i in range( 0, line.NF ):
                    col = self.columnDefs[i]

                    if (line.dollar[i+1] == self.noneIndicator):
                        row[col.name] = None
                    else:
                        # derive conversion function from fmt field
                        if (col.fmt[-1:] in ['f','e','E','g','G']):
                            func = float
                        elif (col.fmt[-1:] in ['d','o','x','X']):
                            func = int
                        else:
                            func = str
                        #end if
                        row[ col.name ] = func( line.dollar[i+1] )
                    #endif
                #end for
            else:
                pass
            #end if
        #end for
        self.tabFile = tabFile
    #end def

    def write( self, stream=sys.stdout):
        """
        Write tab to stream
        """
        for r in self.remarks:
            fprintf( stream, 'REMARK %s\n', r )
        #end for
        fprintf( stream, '\n' )

        for d,v in self.data.iteritems():
            fprintf( stream, 'DATA %s %s\n', d, v ) # Note: only ONE space between DATA and identifier!!!
        #end for
        fprintf( stream, '\n' )

        fprintf(     stream, 'VARS    ' )
        for c in self.columnDefs:
            if not c.hide:
                fprintf( stream, '%s ', c.name )
        #end for
        fprintf( stream, '\n' )

        fprintf(     stream, 'FORMAT  ' )
        for c in self.columnDefs:
            if not c.hide:
                fprintf( stream, '%s ', c.fmt )
        #end for
        fprintf( stream, '\n' )

        fprintf( stream, '\n' )
        for row in self:
            fprintf( stream, '%s\n', row )
        #end for

    #end def

    def writeFile( self, tabFile)   :
        """
        Write table to tabFile.
        Return True on error
        """
        fp = open( tabFile, 'w' )
        if fp is None:
            nTerror('NmrPipeTable.writeFile: error opening "%s"', tabFile)
            return True
        self.write( fp )
        fp.close()
#        nTdebug('==> Written nmrPipe table file "%s"', tabFile )
        return False
    #end def

    #iteration overrides: loop over row indices or rows
    def keys( self ):
        return range( 0, self.nrows )
    #end def

    def __iter__( self ):
        for row in self.rows:
            yield row
        #end for
    #end def
#end def


#-----------------------------------------------------------------------------
# NIH routines
#-----------------------------------------------------------------------------
def exportShifts2TalosPlus( project, fileName=None):
    """Export shifts to TalosPlus format

    Return True on error including situation where no shifts were added to the file.

---------------------------------------------------

An example of the required shift table format is shown below. Complete examples can be found in the talos/shifts and talos/test directories. Specifically:

In the current version of TALOS/TALOS+, residue numbering must begin at 1.
The protein sequence should be given as shown, using one or more "DATA SEQUENCE" lines. Space characters in the sequence will be ignored. Use "c" for oxidized CYS (CB ~ 42.5 ppm) and "C" for reduced CYS (CB ~ 28 ppm) in both the sequence header and the shift table.
The table must include columns for residue ID, one-character residue name, atom name, and chemical shift.
The table must include a "VARS" line which labels the corresponding columns of the table.
The table must include a "FORMAT" line which defines the data type of the corresponding columns of the table.
Atom names are always given exactly as:
    HA       for H-alpha of all residues except glycine
    HA2      for the first H-alpha of glycine residues
    HA3      for the second H-alpha
    C        for C' (CO)
    CA       for C-alpha
    CB       for C-beta
    N        for N-amide
    HN       for H-amide
As noted, there is an exception for naming glycine assignments, which should use HA2 and HA3 instead of HA. In the case of glycine HA2/HA3 assignments, TALOS/TALOS+ will use the average value of the two, so that it is not necessary to have these assigned stereo specifically ; for use of TALOS/TALOS+, the assignment can be arbitrary. Note however that the assignment must be given exactly as either "HA2" or "HA3" rather than "HA2|HA3" etc.
Other types of assignments may be present in the shift table; they will be ignored.

Example shift table (excerpts):

   REMARK Ubiquitin input for TALOS, HA2/HA3 assignments arbitrary.

   DATA SEQUENCE MQIFVKTLTG KTITLEVEPS DTIENVKAKI QDKEGIPPDQ QRLIFAGKQL
   DATA SEQUENCE EDGRTLSDYN IQKESTLHLV LRLRGG

   VARS   RESID RESNAME ATOMNAME SHIFT
   FORMAT %4d   %1s     %4s      %8.3f

     1 M           HA                  4.23
     1 M           C                 170.54
     1 M           CA                 54.45
     1 M           CB                 33.27
     2 Q           N                 123.22
     2 Q           HA                  5.25
     2 Q           C                 175.92
     2 Q           CA                 55.08
     2 Q           CB                 30.76
---------------------------------------------------

From talos+ randcoil.tab file:

REMARK Talos Random Coil Table 2005.032.16.15
REMARK Cornilescu, Delaglio and Bax
REMARK CA/CB from Spera, Bax, JACS 91.
REMARK Others from Wishart et al. J. Biomol. NMR, 5(1995), 67-81
REMARK Pro N shift is the current database average (7 residues).
REMARK HIS = Wishart's val - 0.5*(diff between prot./non-prot. Howarth&Lilley)

DATA RESNAMES  A C c D E F G H I K L M N P Q R S T V W Y
DATA ATOMNAMES HA CA CB C N HN

#
# Values for C are CYS-reduced.
# Values for c are CYS-oxidized.
# Values for H are HIS-unprotonated.
# Values for h are for HIS-protonated.
# Values for D and E are for protonated forms.
---------------------------------------------------

    """

    if not project:
        return True
    #end if

    if not project.molecule:
        nTerror('exportShifts2TalosPlus: no molecule defined')
        return True
    molecule = project.molecule
    residues = molecule.residuesWithProperties('protein')
    if not residues:
        nTerror('exportShifts2TalosPlus: no amino acid defined')
        return True

    table = NmrPipeTable()
    table.remarks.append( sprintf('shifts from %s', molecule.name ) )
    residueOffset = residues[0].resNum-1 # residue numbering has to start from 1
    table.remarks.append( sprintf('residue numbering offset  %d', residueOffset ) )

#   generate a one-letter sequence string; map 'all chains to one sequence'
    seqString = ''
    for res in residues:
#        seqString = seqString + res.db.shortName JFD mod; wrong, look at format def above!
        if res.translate(constants.INTERNAL_0) == 'CYSS':
            seqString = seqString + 'c' # oxidized
        else:
            seqString = seqString + res.db.shortName
    #end for

#   data
    table.data.SEQUENCE = seqString

#   add collun entries
    table.addColumn('RESID',    '%-4d')
    table.addColumn('RESNAME',  '%-4s')
    table.addColumn('ATOMNAME', '%-4s')
    table.addColumn('SHIFT',    '%8.3f')

    # defines IUPAC to talos mapping and nuclei used
    talosDict = dict(
                 N  = 'N',
                 H  = 'HN',
                 CA = 'CA',
                 HA = 'HA',
                 HA2= 'HA2',
                 HA3= 'HA3',
                 QA = 'HA2,HA3', # QA will be translsate into real atoms
                 CB = 'CB',
                 C  = 'C'
                 )
    talosNuclei = talosDict.keys()

    atmCount = 0
    for resId,res in enumerate(residues):
        for ac in res.allAtoms():
            atomName = ac.translate(constants.IUPAC)
            if (ac.isAssigned(resonanceListIdx=constants.RESONANCE_LIST_IDX_ANY) and ( atomName in talosNuclei)):
                shift = ac.shift(resonanceListIdx=constants.RESONANCE_LIST_IDX_ANY) # save the shift, because Gly QA pseudo atom does get expanded
                for ra in ac.realAtoms():
                    atomName = ra.translate(constants.IUPAC)
                    # Translate to TalosPlus
                    if talosDict.has_key(atomName):
                        atomName = talosDict[atomName]
                    else:
                        nTerror('exportShifts2TalosPlus: strange, we should not be here (ra=%s)', ra)
                        continue
                    #end if

                    #print '>', seqString[resId:resId+1]
                    table.addRow( RESID=resId+1, RESNAME=seqString[resId:resId+1], ATOMNAME=atomName, SHIFT=shift)
                    atmCount += 1
                #end for
            #end if
        #end for
    #end for

    # save the table
    if not fileName:
        fileName = molecule.name + '.tab'
    if not table.writeFile(fileName):
        nTmessage( '==> exportShifts2TalosPlus:  %-4d shifts   written to "%s"', atmCount, fileName )
    if atmCount == 0:
        return True
#end def


def _importTableFile( tabFile, molecule ):
    """import a tabFile, match to residue instances of molecule

    Return the NmrPipeTable instance or None on error
    """

    if not os.path.exists( tabFile ):
        nTerror('_importTableFile: table file "%s" not found', tabFile)
        return None

    if molecule==None:
        nTerror('_importTableFile: no molecule defined')
        return None

    # residues for which we will analyze; same as used in export2talosPlus
    residues = molecule.residuesWithProperties('protein')
    if not residues:
        nTerror('_importTableFile: no amino acid defined')
        return None

    table = NmrPipeTable()
    table.readFile(tabFile)

    for row in table:
        # find the residue
        row.residue = None

        if row.RESID > len(residues):
            nTerror('_importTableFile: invalid RESID %d',  row.RESID)
            continue

        # map back onto CING
        res = residues[row.RESID-1] # RESID started at 1
        if res.db.shortName != row.RESNAME.upper(): # also allow for the 'c'
            nTerror('_importTableFile: invalid RESNAME %s and CING %s',  row.RESNAME, res)
            continue

        row.residue = res
        #print res, row
    #end for
    return table
#end def


def _importTalosPlus( project, predFile, ssFile=None ):
    """
    Helper code: Import TalosPlus results from pred.tab and pred.ss.tab
    """

    if not project:
        return True
    #end if

    nTdebug('_importTalosPlus: files %s and %s', predFile, ssFile)

    if not project.molecule:
        nTerror('importTalosPlus: no molecule defined')
        return True
    molecule = project.molecule

    table = _importTableFile( predFile, molecule )

    for row in table:

        #print '>', row, row.residue
        talosPlus = TalosPlusResult()
        talosPlus.residue = row.residue
        talosPlus.phi = NTvalue( row.PHI, row.DPHI, '%6.1f +- %4.1f')
        talosPlus.psi = NTvalue( row.PSI, row.DPSI, '%6.1f +- %4.1f')
        talosPlus.S2  = row.S2
        talosPlus.count = row.COUNT
        talosPlus.classification = row.CLASS

        if talosPlus.classification == 'None' or \
           talosPlus.phi.value == 9999.00 or \
           talosPlus.psi.value == 9999.00:
            talosPlus.phi.value = NaN
            talosPlus.phi.error = NaN
            talosPlus.psi.value = NaN
            talosPlus.psi.error = NaN
            talosPlus.S2 = NaN # pylint: disable=C0103
        #end if

        project.validationData.setResult(row.residue, constants.TALOSPLUS_KEY, talosPlus)
        #LEGACY:
        row.residue.talosPlus = talosPlus
    #end for

    # do the second ss file
    ssdict = dict( H = 'Helix', E='Extended', L='Coil' ) # X is translated to None
    if ssFile:
        table = _importTableFile( ssFile, molecule )
        #print '>>', table
        for row in table:
            #print '>>', row

            if ('residue' in row and row.residue is not None):
                tPlus = project.validationData.getResult(row.residue, constants.TALOSPLUS_KEY)
                if tPlus is not None:
                    tPlus.Q_H = row.Q_H    # Helix
                    tPlus.Q_E = row.Q_E    # Extended
                    tPlus.Q_L = row.Q_L    # Loop
                    if row.SS_CLASS in ssdict:
                        tPlus.ss_class = ssdict[row.SS_CLASS]
                    else:
                        tPlus.ss_class = None
                    tPlus.ss_confidence = row.CONFIDENCE
                else:
                    nTerror('_importTalosPlus: %s: row: %s', ssFile, row)
                #end if
            #end if
        #end for
    #end if
#end def

def _resetTalosPlus(project):
    """Reset the talosPlus references in the data
    """
    for res in project.molecule.allResidues():
        project.validationData.setResult(res, constants.TALOSPLUS_KEY, None)
        #LEGACY:
        res.talosPlus = None
    #end for
#end def


def _findTalosOutputFiles( path, talosDefs ):
    """ Check for existence of the output files; return True on error
    """
    # pred.tab file; curently only one name encountered
    talosDefs.predFile = None
    for tFile in 'pred.tab'.split():
        pFile = path / tFile
        if pFile.exists():
            #print '>found>', pFile
            talosDefs.predFile = tFile # only store local part of name
            break
    #end for
    if talosDefs.predFile == None:
        nTerror("_findTalosOutputFiles: Failed to find pred.tab file")
        return True
    #end if
    # Multiple predSS names found
    talosDefs.predSSFile = None
    for tFile in 'predSS.tab pred.ss.tab'.split():
        pFile = path / tFile
        if pFile.exists():
            #print '>found>', pFile
            talosDefs.predSSFile = tFile # only store local part of name
            break
    #end for
    if talosDefs.predSSFile == None:
        nTerror("_findTalosOutputFiles: Failed to find predSS.tab or pred.ss.tab file")
        return True
    #end if
    return False
#end def


def runTalosPlus(project, tmp=None, parseOnly=False):
    """Perform a talos+ analysis; parses the results; put into new CING dihedral restraint list
    Returns True on error.
    Returns False when talos is absent or when all is fine.
    """
    #LEGACY:
    if parseOnly:
        return parseTalosPlus(project)

    if project is None:
        nTerror("runTalosPlus: No project defined")
        return True

    # check executable
    if cdefs.cingPaths.talos is None:
        nTmessage('runTalosPlus: no talosPlus executable defined, skipping')
        return False # Gracefully return
    status, output = getOsResult('which '+ cdefs.cingPaths.talos )
    if len(output) == 0:
        nTmessage('runTalosPlus: invalid talosPlus executable defined (%s), skipping', cdefs.cingPaths.talos)
        return False # Gracefully return

    if project.molecule is None:
        nTmessage("runTalosPlus: No molecule defined")
        return True

    residues = project.molecule.residuesWithProperties('protein')
    if not residues:
        nTmessage('runTalosPlus: no amino acids defined')
        return False

    if len( project.molecule.resonanceSources ) == 0:
        nTmessage("==> runTalosPlus: No resonances defined so no sense in running.")
        # JFD: This doesn't catch all cases.
        return False

    talosDefs = project.getStatusDict(constants.TALOSPLUS_KEY, **talosDefaults)

    talosDefs.molecule = project.molecule.asPid()
    talosDefs.directory = constants.TALOSPLUS_KEY

    path = project.validationPath( talosDefs.directory )
    if not path:
        return True
    if path.exists():
        nTdebug('runTalosPlus: removing %s with prior data', path)
        path.rmdir()
    path.makedirs()

    startTime = io.now()

    talosDefs.completed = False
    talosDefs.parsed = False
    _resetTalosPlus(project)

    # Exporting the shifts
    fileName = path / talosDefs.tableFile
    if exportShifts2TalosPlus(project, fileName=fileName):
        nTwarning("runTalosPlus: Failed to exportShifts2TalosPlus; this is normal for empty CS list.")
        return False

    # running TalosPlus
    talosProgram = ExecuteProgram(cdefs.cingPaths.talos, rootPath=path, redirectOutput=True)
    nTmessageNoEOL('==> Running talos+ ... ')
    talosProgram( '-in ' + talosDefs.tableFile + ' -sum ' + talosDefs.predFile )
    nTmessage('Done!')

    if _findTalosOutputFiles(path, talosDefs):
        return True

    talosDefs.date = io.now()
    talosDefs.completed=True
    talosDefs.version = __version__
    talosDefs.molecule = project.molecule.asPid()
    talosDefs.remark = 'TalosPlus on %s completed in %.1f seconds on %s; data in %s' % \
                       (project.molecule, talosDefs.date-startTime, talosDefs.date, path)

    # Importing the results
    if parseTalosPlus(project):
        nTerror("runTalosPlus: Failed parseTalosPlus")
        return True

    project.history(talosDefs.remark)
    nTmessage('==> %s', talosDefs.remark)
    return False
#end def


def parseTalosPlus( project, tmp=None ):
    """Import talosPlus results.
    Return True on error.
    """
    if project is None:
        io.warning("parseTalosPlus: No project defined\n")
        return False

    if project.molecule is None:
        io.warning("parseTalosPlus: No molecule defined\n")
        return False

    talosDefs = project.getStatusDict(constants.TALOSPLUS_KEY, **talosDefaults)

    if not talosDefs.completed:
        io.warning("parseTalosPlus: No talos+ was run\n")
        return False

    path = project.validationPath(talosDefs.directory)
    if not path:
        io.error('parseTalosPlus: directory "{0}" with talosPlus data not found\n', path)
        return True

    if _findTalosOutputFiles(path, talosDefs):
        return True

    predFile = path / talosDefs.predFile
    if not predFile.exists() or predFile.isdir():
        io.error('parseTalosPlus: file "{0}" with talosPlus predictions not found\n', predFile)
        return True

    predSSFile = path / talosDefs.predSSFile
    if not predSSFile.exists() or predSSFile.isdir():
        io.error('parseTalosPlus: file "{0}" with talosPlus SS predictions not found\n', predSSFile)
        return True

    _resetTalosPlus(project)
    if _importTalosPlus(project, predFile, predSSFile):
        return True

    talosDefs.parsed = True

    if talosPlus2restraints(project):
        io.error("parseTalosPlus: Failed talosPlus2restraints\n")
        return True

    return False
#end def


def talosPlus2restraints( project, name=constants.TALOSPLUS_LIST_STR, status='noRefine', errorFactor=2.0 ):
    """
    Convert talos+ results to a CING dihedral restraint list
    """
    if project == None:
        nTmessage("talosPlus2restraints: No project defined")
        return True

    if project.molecule == None:
        nTmessage("talosPlus2restraints: No project defined")
        return True

    if not project.status.has_key('talosPlus') or not project.status.talosPlus.completed:
        nTmessage("talosPlus2restraints: No talos+ data")
        return True

    if name in project.dihedrals.names():
        project.dihedrals.delete(name)

    dhl = project.dihedrals.new(name=name, status=status)
    for res in project.molecule.allResidues():
        if res.talosPlus and res.talosPlus.classification=='Good':
            lower = res.talosPlus.phi.value-errorFactor*res.talosPlus.phi.error
            upper = res.talosPlus.phi.value+errorFactor*res.talosPlus.phi.error
            atoms = getDeepByKeysOrAttributes( res, constants.PHI_STR, constants.ATOMS_STR )
            if atoms:
                d = DihedralRestraint(atoms, lower, upper)
                dhl.append(d)

            lower = res.talosPlus.psi.value-errorFactor*res.talosPlus.psi.error
            upper = res.talosPlus.psi.value+errorFactor*res.talosPlus.psi.error
            atoms = getDeepByKeysOrAttributes( res, constants.PSI_STR, constants.ATOMS_STR )
            if atoms:
                d = DihedralRestraint(atoms, lower, upper)
                dhl.append(d)
        #end if
    #end for
    nTmessage('==> Created %s', dhl)
#end def


def export2nih( project, tmp=None ):
    """
    Export resonances to NIH (talos) format
    """

    talosDefs = project.getStatusDict(constants.TALOSPLUS_KEY, **talosDefaults)
    for mol in project.molecules:
        fileName = project.path() / project.cdefs.directories.nih /  mol.name +'.'+talosDefs.tableFile
        exportShifts2TalosPlus(  project, fileName=fileName )
    #end for
#end def

#-----------------------------------------------------------------------------

# register the functions
methods  = [(runTalosPlus,None),
            (parseTalosPlus,None),
            (talosPlus2restraints,None)
           ]
saves    = []
restores = []
exports  = [(export2nih, None)]


#-----------------------------------------------------------------------------
# Testing from here-on
#-----------------------------------------------------------------------------
#
if __name__ == '__main__':
    pass


